<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Swarm Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #00ffcc; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,20,20,0.8); padding: 15px; border-left: 5px solid #00ffcc; pointer-events: none; }
        #webcam-preview { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border: 1px solid #00ffcc; transform: scaleX(-1); opacity: 0.5; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 1.2em; letter-spacing: 2px;">SWARM CORE V2.0</div>
        <div id="status">Scanning for bio-signature...</div>
        <div id="mode" style="font-size: 0.8em; margin-top: 5px; color: #fff;">MODE: CHAOS DRIFT</div>
    </div>
    <video id="webcam-preview" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. THE DUAL-LOGIC PARTICLE SYSTEM ---
        const particleCount = 10000;
        const geometry = new THREE.BufferGeometry();
        
        const basePos = new Float32Array(particleCount * 3);    // Group: The Sphere Target
        const randomPos = new Float32Array(particleCount * 3);  // Group: The Chaos Target
        const currentPos = new Float32Array(particleCount * 3); // The Current Live Position
        const velocities = new Float32Array(particleCount * 3); // Individual: Particle "jitters"

        for (let i = 0; i < particleCount; i++) {
            // Group Shape: Sphere
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            basePos[i*3] = 2.5 * Math.cos(theta) * Math.sin(phi);
            basePos[i*3+1] = 2.5 * Math.sin(theta) * Math.sin(phi);
            basePos[i*3+2] = 2.5 * Math.cos(phi);

            // Group Shape: Chaos
            randomPos[i*3] = (Math.random() - 0.5) * 15;
            randomPos[i*3+1] = (Math.random() - 0.5) * 15;
            randomPos[i*3+2] = (Math.random() - 0.5) * 15;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
        const material = new THREE.PointsMaterial({ 
            color: 0x00ffcc, size: 0.02, transparent: true, blending: THREE.AdditiveBlending 
        });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        camera.position.z = 7;

        // --- 3. TRACKING & INTERACTION ---
        let formationFactor = 0; 
        let fingertips = []; // Will store 3D positions of all 5 fingers

        function onResults(results) {
            fingertips = [];
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('mode').innerText = "MODE: QUANTUM ASSEMBLY";
                formationFactor += (1 - formationFactor) * 0.1;

                const hand = results.multiHandLandmarks[0];
                // Track tips: Thumb(4), Index(8), Middle(12), Ring(16), Pinky(20)
                [4, 8, 12, 16, 20].forEach(index => {
                    fingertips.push(new THREE.Vector3(
                        (hand[index].x - 0.5) * 10,
                        -(hand[index].y - 0.5) * 10,
                        -(hand[index].z * 10)
                    ));
                });
            } else {
                document.getElementById('mode').innerText = "MODE: CHAOS DRIFT";
                formationFactor += (0 - formationFactor) * 0.02;
            }

            const posAttr = geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // --- PART A: GROUP BEHAVIOR (The Lerp) ---
                const targetX = randomPos[i3] + (basePos[i3] - randomPos[i3]) * formationFactor;
                const targetY = randomPos[i3+1] + (basePos[i3+1] - randomPos[i3+1]) * formationFactor;
                const targetZ = randomPos[i3+2] + (basePos[i3+2] - randomPos[i3+2]) * formationFactor;

                // Move toward group target
                posAttr[i3] += (targetX - posAttr[i3]) * 0.1;
                posAttr[i3+1] += (targetY - posAttr[i3+1]) * 0.1;
                posAttr[i3+2] += (targetZ - posAttr[i3+2]) * 0.1;

                // --- PART B: INDIVIDUAL BEHAVIOR (Finger Repulsion/Reaction) ---
                fingertips.forEach(finger => {
                    const dx = posAttr[i3] - finger.x;
                    const dy = posAttr[i3+1] - finger.y;
                    const dz = posAttr[i3+2] - finger.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist < 1.5) { // If finger is close to an individual particle
                        const force = (1.5 - dist) * 0.2;
                        posAttr[i3] += dx * force;
                        posAttr[i3+1] += dy * force;
                        posAttr[i3+2] += dz * force;
                    }
                });

                // Add small individual jitter
                posAttr[i3] += (Math.random() - 0.5) * 0.01;
                posAttr[i3+1] += (Math.random() - 0.5) * 0.01;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const video = document.getElementById('webcam-preview');
        const mediaCam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        mediaCam.start();

        function animate() {
            requestAnimationFrame(animate);
            points.rotation.y += 0.002;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>